# Docker

### Docker Introduction

Docker was first released in 2013 by Solomon Hykes and has since become a standard tool for containerization. It helps solve the common problem of ‚ÄúIt works on my computer, but not on yours.‚Äù With Docker, apps run the same way everywhere whether it's on your laptop, a test server, or in the cloud.Key features include:

- **Portability**: Containers can run on any system with Docker installed, from a developer's laptop to cloud servers.
- **Efficiency**: Containers are lightweight, using fewer resources than VMs.
- **Isolation**: Each container runs in its own environment, preventing conflicts between applications.
- **Versioning**: Docker images can be versioned, enabling rollbacks and consistent deployments.
- **Ecosystem**: Docker Hub provides a repository for sharing and managing container images.

### **What is Docker?**

Docker is an¬†open-source platform that automates deployment, scaling, and management of applications using containerization. It packages applications with their dependencies (code, runtime, libraries, configurations) into containers that are lightweight, portable, and consistent across¬†environments.

**The Problem Docker Solves**

The "it works on my machine" problem:

- Different OS¬†versions
- Missing dependencies
- Configuration differences
- Environment inconsistencies

Docker ensures applications¬†run the same way on¬†development, testing, and production.

### **Containers vs Virtual Machines**

Unlike virtual machines (VMs), which include an entire operating system, containers share the host OS kernel, making them more efficient in terms of resource usage and startup time.

- Agar host machine Linux hai ‚Üí container Linux kernel use karega
- Container ko alag se OS install nahi karna padta

**Virtual Machines (VMs):**

- Imagine you want to run several apps on your computer.
- With VMs, each app gets its own full operating system (like Windows or Linux).
- Heavy: needs CPU, RAM, and¬†disk for the OS
- VMs are slow to start because they boot a whole OS.

**Containers (like Docker):**

- Containers don‚Äôt need a full OS for each app.
- Instead, they **share the host's OS**, but still keep each app **isolated**.
- Much faster and use less resources.
- Think of them like running apps in "boxes" that are lightweight and quick.

| Aspect | Virtual Machines | Docker Containers |
| --- | --- | --- |
| **OS** | Full OS per VM | Shares host OS kernel |
| **Size** | GBs (OS + app) | MBs (app + dependencies) |
| **Startup Time** | Minutes | Seconds |
| **Resource Usage** | High¬†(dedicated resources) | Low (shared resources) |
| **Isolation** | Hardware-level | Process-level |
| **Use Case** | Complete OS isolation | Application isolation |

## Docker Architecture

Docker follows a **client-server architecture** that enables efficient creation, deployment, and management of containers. . Below is an overview of its architecture and key components:

**What is Client-Server Architecture?**

Client-server architecture is a model where:

- One part is the client (asks for something).
‚Ä¢ **Client**: Sends commands (CLI, GUI, API)
- The other part is the server (does the work and gives the result).
‚Ä¢ **Server (Daemon)**: Executes commands and manages Docker objects
- The client sends a request, and the server gives a response.

### **Core Components**

1. **Docker Engine**

The Docker Engine is the core of Docker, responsible for creating and managing containers. It consists of:

- **Docker Daemon (dockerd)**: A background process that manages Docker objects.
    - Managing Docker objects like **images**, **containers**, **networks**, and **volumes**.
    - Runs continuously on your system
    - Handles¬†all Docker operations
    - Handling requests from Docker clients through the REST API.
    - Building, running, and distributing containers.

```bash
You type: docker run nginx
    ‚Üì
Docker Client sends request
    ‚Üì
Docker Daemon receives request
    ‚Üì
Daemon checks if nginx image exists
    ‚Üì
If not, downloads from registry
    ‚Üì
Creates container from image
    ‚Üì
Starts container
    ‚Üì
Returns result to client
```

- **Docker Client**: The command-line interface (CLI) or GUI used by users to interact with the Docker Daemon (e.g., commands like docker run, docker build,docker ps). The client sends requests to the daemon via the Docker API.
- **REST API**: The interface that allows the Docker Client and other tools to communicate with the Docker Daemon. When you run a Docker command (e.g., `docker run hello-world`), the Docker CLI sends an **HTTP request** to the Docker Daemon over the REST API.

### 2. **Docker Images**

- A Docker image is a read-only template used to create containers.
- Images are built using a Dockerfile, a script with instructions to assemble the image
- (e.g., installing dependencies, Application¬†code,Configuration files,copying files).
- Images are stored in repositories like Docker Hub or private registries.

### 3. **Docker Containers**

- A container is a runnable instance of a Docker image.
- Its own filesystem, Its own network, Its own process space
,Resource limits.
- It includes the application and its environment, running in an isolated space on the host OS.
- You can start, stop, pause, restart, or remove containers using Docker commands.

### 4. **Docker Registry**

- A Docker Registry is a service that stores and distributes Docker images.
- **Public Registries**: Docker¬†Hub (default).
- **Private¬†Registries**: AWS ECR, Azure Container Registry, Google Container Registry, Harbor

### **Core Concepts**

**Image vs Container**

- **Image**: Blueprint¬†(read-only template)
- **Container**: Instance of an image (runnable, writable)

**Container Isolation**

Containers use:

- **Namespaces**: Isolate¬†processes, networks, filesystems
- **Control Groups (cgroups)**: Limit and account for resource¬†usage
- **Union File Systems**: Efficient layer management

![how-does-docker-work.png](attachment:35c5f15e-f403-4fe6-9c90-57c6d6862b4a:how-does-docker-work.png)

### What is a **Dockerfile**?

A Dockerfile is a text file that contains instructions on how to build a Docker image.

It specifies the base image, the application code, dependencies, and other configurations needed to create a runnable image.

```bash
FROM python:3.9
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
ENTRYPOINT ["python"]
CMD ["app.py"]
```

Copies **files or directories** from your local host **into the image**.

```bash
COPY <source> <destination>
```

```bash
COPY ./app /usr/src/app
```

 `CMD` is an instruction used in a `Dockerfile` to specify the default command that runs when a container starts.

```bash
CMD ["executable", "param1", "param2"]
```

```bash
CMD ["node", "app.js"]
```

`ENTRYPOINT` sets the main command that always runs in the container, while `CMD` provides default arguments that can be overridden when you run the container.

```bash
ENTRYPOINT ["python"]
CMD ["app.py"]
```

**ADD** Like `COPY`, but adds extra features: Can extract `.tar`, `.tar.gz`, `.tar.bz2` files.

```bash
ADD <source> <destination>
```

```bash
ADD app.tar.gz /usr/src/app
```

**.dockerignore File**

Exclude files from build context (like .gitignore).

```bash
# .dockerignore
node_modules
npm-debug.log
.git
.gitignore
.env
*.md
.DS_Store
dist
coverage
```

### Docker Commands

The following docker commands:

**Docker Info:-**Displays detailed information about the Docker installation and current server status.

```bash
docker info
```

**Docker Server Start:-**Use this when you want to manually start Docker on your system

```bash
sudo systemctl start docker
```

**Automatic Start:-**If you want Docker to start **automatically every time** your system boots up

```bash
sudo systemctl enable docker
```

**Docker Server Status:-**Shows the current status of the Docker service.

```bash
sudo systemctl status docker
```

**Docker Images:**

Lists all Docker images stored on your local machine.

Repository name, tag, image ID, creation time, and size.

```bash
# List all images
docker images
# or
docker image ls

# Show only image IDs
docker images -q

# Show image sizes
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"
```

**Docker Image Creation:** builds an image from the Dockerfile in the current directory.

```bash
docker build -t myapp:1.0 .
```

**Docker Tag Existing Image:**

Adds a new tag (name/version) to an existing Docker image. This is often used when preparing an image to be pushed to a registry (like Docker Hub or a private registry).

```bash
docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]
```

You have an image called `myapp` with tag `latest`, and you want to tag it for Docker Hub under your username (`username/myapp`) as version `v1.0`:

```bash
# Tag an image
docker tag source-image:tag target-image:tag

# Example: Tag for Docker Hub
docker tag myapp:latest username/myapp:v1.0

# Tag with different name
docker tag myapp:latest myapp:production
```

**Docker image pull:**  Downloads an image from a Docker registry (like Docker Hub)

```bash
# Pull latest tag
docker pull ubuntu

# Pull specific tag
docker pull ubuntu:20.04

# Pull from different registry
docker pull registry.example.com/myimage:tag
```

**Docker image push:** Uploads an image to a registry (like Docker Hub).

```bash
# Login to registry
docker login

# Push image
docker push username/myapp:v1.0

# Push to private registry
docker push registry.example.com/myapp:v1.0
```

**Docker image inspect:** Shows detailed JSON metadata about an image.outputs data like ID, size, layers, OS, architecture, etc.

```bash
docker image inspect image-name

# View detailed image information
docker image inspect ubuntu:20.04
```

**Docker image save:** Exports a Docker image into a **.tar** file and Sharing an image with others without using Docker Hub

```bash
docker image save -o <file_name>.tar <image_name>:<tag>
```

```bash
docker image save -o myapp_image.tar myapp:latest
```

**Docker image load:** Loads an image from a **.tar** archive into your Docker system.

You receive an image file from someone else.

```bash
docker image load -i < <file_name>.tar
```

```bash
docker image load -i myapp_image.tar
```

**Remove Images:**

```bash
# Remove specific image
docker rmi image-name:tag

# Remove by ID
docker rmi abc123def456

# Force remove (even if in use)
docker rmi -f image-name:tag

# Remove all unused images
docker image prune

# Remove all images
docker rmi $(docker images -q)
```

**Essential Container Commands**

**Create  and Run Container:**

 Start and run a new container using the official Ubuntu Docker image

```bash
# Run container (create + start)
docker run ubuntu

```

if you don‚Äôt attach to it (`-it`) or give it a command, the container may start and exit immediately, because there's nothing to keep it running.

```bash
docker run -it ubuntu
```

Create and Run a new container using the Ubuntu image.

/etc/os-release It‚Äôs a file that contains information about the operating system inside the container

```bash
docker run ubuntu cat /etc/os-release
```

```bash
# list of container
docker container ls  
docker ps
docker ps -a
```

**Docker Container Custom Name:** Run a new container and assign it a custom name.

Docker generates a random name for containers, but you can specify one using `--name`

```bash
docker run --name <container_name> [other options] <image> [command]
```

**Remove Docker Container:**

This is used to **remove a Docker container** named (or with ID) ubuntu

```bash
# Remove stopped container
docker rm ubuntu
```

```bash
# Force remove (running container)
docker rm -f <containerID>
```

**Start & Stop Container:**

It takes a container that was previously created (and then stopped) and **boots it up again**, without creating a new container.only works on containers that already exist (either stopped or paused). It does not create new containers.

```bash
docker start name-containerid
docker stop name-containerid
docker pause name-containerid
```

```bash
docker kill container-name
```

**Deteached Container:**

Runs the container in **detached mode**, meaning the container runs in the background, so you can keep using the terminal right away.

```bash
docker run -d ubuntu
```

**Docker Inspect:**

docker container inspect is used to retrieve **detailed, low-level information** about a specific Docker container.

Returns a JSON-formatted output that shows everything about the container, such as:

Configuration, Networking, Mounts (volumes), Environment variables, Resource limits, State (running, exited, etc.)

You might use `docker container inspect` to:

- **Debug** issues with a container.
- Check **which port** is mapped to the host.
- See **volume mounts** and paths.
- Find the **IP address** of a container.
- View the **entrypoint and command** used to run the container.
- View environment variables (`Env`).

```bash
docker container inspect <container_name_or_id>
```

**Docker Logs:**

The docker container logs command is used to view the logs (output) from a running or stopped Docker container.

Standard Output (stdout) and Standard Error (stderr) from the container‚Äôs main process.

```bash
docker container logs <container_name_or_id>
```

**Docker Container Top:**

display the running processes inside a specific Docker container 

Provides a snapshot of the process list with details like:PID (process ID), User, CPU / memory usage, Command running

```bash
docker container top <container_name_or_id>
```

**Docker Container Start form image:**

starts a new container from the specified image with some specific options.

Automatically maps **exposed ports** from the container to **random high ports** on the **host** machine.

```bash
docker container run -P -it image-name
```

### Docker Port Mapping

When you run an application inside a Docker container, it operates in isolation including its network. This means:

- The app inside the container listens on a private/internal port.
- By default, this port is not accessible from your host machine or browser.

**Port Mapping solves this by creating a bridge:**

It connects a port on your host (e.g., your laptop or server) to a port inside the container, allowing external access.

```bash
docker run -p <host_port>:<container_port> image_name
docker run -p 8080:80 nginx
```

Maps host port 8080 to container port 80.

**Rename a Docker Container:** Useful for making container names more meaningful after creation.

```bash
docker rename <old_name_or_id> <new_name>
```

**Restart a Docker Container:** Stops the container and starts it again.

```bash
docker restart <container_name_or_id>
docker restart my_web_app
```

 **Execute Commands Inside a Running Container:** Opens an interactive terminal inside the container that‚Äôs already running.

```bash
docker exec -it <container_name> <command>
```

```bash
#Opens a Bash shell (like a terminal) inside the container.
docker exec -it my_container bash
```

**Detached Mode:** Starts a new container in detached mode (runs in background).

`-d` = detached (no terminal output shown)

```bash
docker container run -d <container_name_or_id>
```

**Docker with terminal:** Starts a new Ubuntu container interactively in the background with a terminal 

You want to start a Linux shell environment to interact with later.

```bash
docker container run -itd --name myubuntu ubuntu /bin/bash
```

**What happens:**

- run container
- Starts bash shell
- You're now INSIDE container
- Can run¬†commands
- Type¬†exit¬†to leave

**Docker wait :** Waits for the container to exit and returns its exit status code.

Useful in scripting or CI/CD pipelines to check if a container completed successfully.

```bash
docker container wait my_job_container
```

**Docker Pause:** Pauses all processes in a container (like a "freeze")

Temporarily halt an app without stopping it completely.

```bash
docker container pause <container_name_or_id>
```

**Docker Delete:** Deletes all stopped containers to free up disk space.

```bash
docker container prune
```

**Docker Export:** Exports the entire container‚Äôs file system as a `.tar` archive.

```bash
docker container export myubuntu > my_ubuntu_tree.tar
```

**Docker Import:**  Imports a container's `.tar` file as a new image.

Recreate a container from an exported snapshot on another machine or system.

- `my_ubuntu_tree.tar`: File exported from a container.
- `my_ubuntu_t`: New image name (tag).

```bash
docker image import my_ubuntu_tree.tar my_ubuntu_t
```

### **Docker Networks:**

A docker network is basically a connection between one or more containers. one of the more powerful things about the docker containers is that they can be easily connect to one other and event other software, this makes it very easy to isolate and manage the containers.

**The Problem:**

By default, containers are¬†isolated:

- Can't communicate with each other
- Can't access host network
- Can't¬†be accessed from outside

**Docker Networking Solution:**

Docker provides networking so containers can:

- Communicate with each¬†other
- Access the internet
- Be accessed from host/outside

Lists all Docker networks on your system.

Network ID, name, driver (e.g., bridge, host), and scope.

```bash
docker network ls
```

### What is a **Docker Volume**?

A Docker Volume is a persistent storage mechanism used by Docker containers to store data outside the container‚Äôs writable layer. This means:

- Data stored in volumes persists even if the container is deleted or recreated.
- Volumes are managed by Docker, making them easier and safer to use than directly mapping host directories.
- Docker volume is not created inside a container. Instead, a docker volume is created separately form the container and can be mounted to one or more containers.

---

### Why use Docker Volumes?

- Containers are temporary: when you delete a container, any changes or files you added inside it are lost.
- Volumes help save your data even if the container stops or is deleted.
- Useful for databases, logs, or any app data you want to persist.

---

### How Docker Volumes work

- Docker creates a volume stored on the host (location managed by Docker).
- You **mount** this volume inside one or more containers at a specified path.
- Containers can **read and write** to this volume as if it were local storage.

```bash
docker run --name python-c1 -itd -v C:\users\yash\Desktop\myside:/myapp python
```

- Run a Python container named `python-c1` in the background and **mount a bind mount** from your Windows host.
- `v C:\users\yash\Desktop\myside:/myapp`: Mounts your **local folder** into the container at `/myapp`.
- `itd`: Interactive (`i`), TTY (`t`), Detached (`d`). After this, any changes in `C:\users\yash\Desktop\myside` are visible inside the container at `/myapp`, and vice versa.

---

```bash
docker exec -it python-c1 bash
```

- Open an interactive **Bash shell inside the `python-c1` container**.
- `it`: Interactive terminal.
- `bash`: Starts a shell.

**Create Docker Volume:**

```bash
docker volume create myvol
```

- Create a **Docker-managed volume** named `myvol` Data in this volume will persist even if the container using it is removed.

List all volumes on the system.

```bash
docker volume ls
```

Show details about the `myvol` volume, including mount path on the host and usage.

```bash
docker volume inspect myvol
```

 Start a new Python container named `c1` and mount the volume `myvol` at `/myapp` inside the container.

Data written to `/myapp` will be stored in the Docker volume and survive container removal.

```bash
docker run --name c1 -itd -v myvol:/myapp python
```

Open a bash shell inside container `c1`, just like before.

```bash
docker exec -it c1 bash
```

**Docker volume delete:** Deletes the volume named `myvol` You must stop and remove all containers using the volume before this will work.

```bash
docker rm -f c1
docker volume rm myvol
```

## What is **Docker Compose**?

Docker Compose is a tool that allows you to define and manage multi-container Docker applications using a single YAML configuration file (`docker-compose.yml`).

Instead of running multiple `docker run` commands manually, Docker Compose lets you define:

- What services (containers) to run
- What images, volumes, and networks they use
- How they interact with each other

üßæ Example `docker-compose.yml`

```yaml
version: "3"
services:
  web:
    image: nginx
    ports:
      - "80:80"
  redis:
    image: redis
```

This starts two services:

- A web server (Nginx) on port 80 and A Redis server

Create Docker compose

```bash
docker-compose up
```

Add `-d` for detached mode (runs in background):

```bash
docker-compose up -d
```

Stop the app

```bash
docker-compose down
```

List running containers

```bash
docker-compose ps
```

Build images defined in the file

```bash
docker-compose build
```

View logs from services

```bash
docker-compose logs
```

Stops and removes containers, networks, and also deletes volumes associated with the services.

Normally, volumes persist even if you bring the containers down. Adding `--volumes` cleans up volumes, so all data is removed.

```bash
docker-compose down --volumes
```

**Example: Web App + Database**

```yaml
version: "3"
services:
  app:
    build: .
    ports:
      - "5000:5000"
    depends_on:
      - db

  db:
    image: postgres
    environment:
      POSTGRES_PASSWORD: example
```

- `app` is built from a Dockerfile in the current directory
- `db` is a PostgreSQL container
- The app depends on the database

### **How to use a `.env` file with Docker Compos**

- Docker Compose automatically looks for a `.env` file in the same directory as the `docker-compose.yml`.
- This file is used to set environment variables referenced in your Compose file.

**Example `.env` file:**

```bash
MYSQL_ROOT_PASSWORD=mysecretpassword
REDIS_PORT=6379
```

Example `docker-compose.yml` referencing these variables:

```bash
version: "3"
services:
  db:
    image: mysql
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
  redis:
    image: redis
    ports:
      - "${REDIS_PORT}:6379"
```
