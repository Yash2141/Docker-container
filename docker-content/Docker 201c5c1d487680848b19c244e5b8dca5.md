# Docker

Docker is an **open-source platform** designed to automate the deployment, scaling, and management of applications using **containerization**.

Instead of installing software on physical or virtual machines, Docker allows you to package your application with all its dependencies (code, runtime, libraries, and configurations) into a container. These containers are lightweight, portable, and consistent across environment from development to production.

Unlike virtual machines (VMs), which include an entire operating system, containers share the host OS kernel, making them more efficient in terms of resource usage and startup time.

**Virtual Machines (VMs):**

- Imagine you want to run several apps on your computer.
- With VMs, each app gets its own full operating system (like Windows or Linux).
- This takes up a lot of memory and CPU.
- VMs are slow to start because they boot a whole OS.

**Containers (like Docker):**

- Containers don‚Äôt need a full OS for each app.
- Instead, they **share the host's OS**, but still keep each app **isolated**.
- Much faster and use less resources.
- Think of them like running apps in "boxes" that are lightweight and quick.

### Docker Introduction

Docker was first released in 2013 by Solomon Hykes and has since become a standard tool for containerization. It helps solve the common problem of ‚ÄúIt works on my computer, but not on yours.‚Äù With Docker, apps run the same way everywhere whether it's on your laptop, a test server, or in the cloud.Key features include:

- **Portability**: Containers can run on any system with Docker installed, from a developer's laptop to cloud servers.
- **Efficiency**: Containers are lightweight, using fewer resources than VMs.
- **Isolation**: Each container runs in its own environment, preventing conflicts between applications.
- **Versioning**: Docker images can be versioned, enabling rollbacks and consistent deployments.
- **Ecosystem**: Docker Hub provides a repository for sharing and managing container images.

## Docker Architecture

Docker follows a **client-server architecture** that enables efficient creation, deployment, and management of containers. . Below is an overview of its architecture and key components:

**What is Client-Server Architecture?**

Client-server architecture is a model where:

- One part is the client (asks for something).
- The other part is the server (does the work and gives the result).
- The client sends a request, and the server gives a response.

### 1. **Docker Engine**

The Docker Engine is the core of Docker, responsible for creating and managing containers. It consists of:

- **Docker Daemon (dockerd)**: A background process that manages Docker objects (images, containers, networks, and volumes).
    - Managing Docker objects like **images**, **containers**, **networks**, and **volumes**.
    - Handling requests from Docker clients through the REST API.
    - Building, running, and distributing containers.
- **Docker Client**: The command-line interface (CLI) or GUI used by users to interact with the Docker Daemon (e.g., commands like docker run, docker build,docker ps). The client sends requests to the daemon via the Docker API.
- **REST API**: The interface that allows the Docker Client and other tools to communicate with the Docker Daemon. When you run a Docker command (e.g., `docker run hello-world`), the Docker CLI sends an **HTTP request** to the Docker Daemon over the REST API.

### 2. **Docker Images**

- A Docker image is a read-only template used to create containers.
- Images are built using a Dockerfile, a script with instructions to assemble the image (e.g., installing dependencies, copying files).
- Images are stored in repositories like Docker Hub or private registries.

### 3. **Docker Containers**

- A container is a runnable instance of a Docker image.
- It includes the application and its environment, running in an isolated space on the host OS.
- You can start, stop, pause, restart, or remove containers using Docker commands.

### 4. **Docker Registry**

- A Docker Registry is a service that stores and distributes Docker images.
- The default is Docker Hub, but private registries are also commonly used.

![how-does-docker-work.png](Docker%20201c5c1d487680848b19c244e5b8dca5/how-does-docker-work.png)

### What is **Docker Compose**?

- A tool to define and run multi-container applications using a YAML file (`docker-compose.yml`).
- Simplifies starting multiple services (e.g., app + database).

```bash
# Example docker-compose.yml:
version: '3'
services:
  web:
    image: nginx
    ports:
      - "8080:80"
  db:
    image: postgres

```

```bash
docker-compose up
```

### What is a **Dockerfile**?

A Dockerfile is a text file that contains instructions on how to build a Docker image.

It specifies the base image, the application code, dependencies, and other configurations needed to create a runnable image.

```bash
FROM python:3.9
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
ENTRYPOINT ["python"]
CMD ["app.py"]
```

```bash
Dockerfile (Entrypoint)
```

Copies **files or directories** from your local host **into the image**.

```bash
COPY <source> <destination>
```

```bash
COPY ./app /usr/src/app
```

 `CMD` is an instruction used in a `Dockerfile` to specify the default command that runs when a container starts.

```bash
CMD ["executable", "param1", "param2"]
```

```bash
CMD ["node", "app.js"]
```

`ENTRYPOINT` sets the main command that always runs in the container, while `CMD` provides default arguments that can be overridden when you run the container.

```bash
ENTRYPOINT ["python"]
CMD ["app.py"]
```

**ADD** Like `COPY`, but adds extra features: Can extract `.tar`, `.tar.gz`, `.tar.bz2` files.

```bash
ADD <source> <destination>
```

```bash
ADD app.tar.gz /usr/src/app
```

### Docker Commands

The following docker commands:

**Docker Info:-**Displays detailed information about the Docker installation and current server status.

```bash
docker info
```

**Docker Server Start:-**Use this when you want to manually start Docker on your system

```bash
sudo systemctl start docker
```

**Automatic Start:-**If you want Docker to start **automatically every time** your system boots up

```bash
sudo systemctl enable docker
```

**Docker Server Status:-**Shows the current status of the Docker service.

```bash
sudo systemctl status docker
```

**Docker Images:**

Lists all Docker images stored on your local machine.

Repository name, tag, image ID, creation time, and size.

```bash
docker container ls  
docker ps
```

**Docker Networks:**

Lists all Docker networks on your system.

Network ID, name, driver (e.g., bridge, host), and scope.

```bash
docker network ls
```

**Create  and Run Container:**

 Start and run a new container using the official Ubuntu Docker image

```bash
docker run ubuntu
```

if you don‚Äôt attach to it (`-it`) or give it a command, the container may start and exit immediately, because there's nothing to keep it running.

```bash
docker run -it ubuntu
```

Create and Run a new container using the Ubuntu image.

/etc/os-release It‚Äôs a file that contains information about the operating system inside the container

```bash
docker run ubuntu cat /etc/os-release
```

**Docker Container Custom Name:** Run a new container and assign it a custom name.

Docker generates a random name for containers, but you can specify one using `--name`

```bash
docker run --name <container_name> [other options] <image> [command]
```

**Remove Docker Container:**

This is used to **remove a Docker container** named (or with ID) ubuntu

```bash
docker rm ubuntu
```

**Start & Stop Container:**

It takes a container that was previously created (and then stopped) and **boots it up again**, without creating a new container.only works on containers that already exist (either stopped or paused). It does not create new containers.

```bash
docker start name-containerid
docker stop name-containerid
```

**Deteached Container:**

Runs the container in **detached mode**, meaning the container runs in the background, so you can keep using the terminal right away.

```bash
docker run -d ubuntu
```

**Docker Inspect:**

docker container inspect is used to retrieve **detailed, low-level information** about a specific Docker container.

Returns a JSON-formatted output that shows everything about the container, such as:

Configuration, Networking, Mounts (volumes), Environment variables, Resource limits, State (running, exited, etc.)

You might use `docker container inspect` to:

- **Debug** issues with a container.
- Check **which port** is mapped to the host.
- See **volume mounts** and paths.
- Find the **IP address** of a container.
- View the **entrypoint and command** used to run the container.
- View environment variables (`Env`).

```bash
docker container inspect <container_name_or_id>
```

**Docker Logs:**

The docker container logs command is used to view the logs (output) from a running or stopped Docker container.

Standard Output (stdout) and Standard Error (stderr) from the container‚Äôs main process.

```bash
docker container logs <container_name_or_id>
```

**Docker Container Top:**

display the running processes inside a specific Docker container 

Provides a snapshot of the process list with details like:PID (process ID), User, CPU / memory usage, Command running

```bash
docker container top <container_name_or_id>
```

**Docker Container Start form image:**

starts a new container from the specified image with some specific options.

Automatically maps **exposed ports** from the container to **random high ports** on the **host** machine.

```bash
docker container run -P -it image-name
```

### Docker Port Mapping

When you run an application inside a Docker container, it operates in isolation including its network. This means:

- The app inside the container listens on a private/internal port.
- By default, this port is not accessible from your host machine or browser.

**Port Mapping solves this by creating a bridge:**

It connects a port on your host (e.g., your laptop or server) to a port inside the container, allowing external access.

```bash
docker run -p <host_port>:<container_port> image_name
docker run -p 8080:80 nginx
```

Maps host port 8080 to container port 80.

**Rename a Docker Container:** Useful for making container names more meaningful after creation.

```bash
docker rename <old_name_or_id> <new_name>
```

**Restart a Docker Container:** Stops the container and starts it again.

```bash
docker restart <container_name_or_id>
docker restart my_web_app
```

 **Execute Commands Inside a Running Container:** Opens an interactive terminal inside the container that‚Äôs already running.

```bash
docker exec -it <container_name> <command>
```

```bash
#Opens a Bash shell (like a terminal) inside the container.
docker exec -it my_container bash
```

**Detached Mode:** Starts a new container in detached mode (runs in background).

`-d` = detached (no terminal output shown)

```bash
docker container run -d <container_name_or_id>
```

**Docker with terminal:** Starts a new Ubuntu container interactively in the background with a terminal 

You want to start a Linux shell environment to interact with later.

```bash
docker container run -itd --name myubuntu ubuntu /bin/bash
```

**Docker wait :** Waits for the container to exit and returns its exit status code.

Useful in scripting or CI/CD pipelines to check if a container completed successfully.

```bash
docker container wait my_job_container
```

**Docker Pause:** Pauses all processes in a container (like a "freeze")

Temporarily halt an app without stopping it completely.

```bash
docker container pause <container_name_or_id>
```

**Docker Delete:** Deletes all stopped containers to free up disk space.

```bash
docker container prune
```

**Docker Export:** Exports the entire container‚Äôs file system as a `.tar` archive.

```bash
docker container export myubuntu > my_ubuntu_tree.tar
```

**Docker Import:**  Imports a container's `.tar` file as a new image.

Recreate a container from an exported snapshot on another machine or system.

- `my_ubuntu_tree.tar`: File exported from a container.
- `my_ubuntu_t`: New image name (tag).

```bash
docker image import my_ubuntu_tree.tar my_ubuntu_t
```

**Docker Image Creation:** builds an image from the Dockerfile in the current directory.

```bash
docker build -t myapp:1.0 .
```

**Docker Tag Existing Image:**

Adds a new tag (name/version) to an existing Docker image. This is often used when preparing an image to be pushed to a registry (like Docker Hub or a private registry).

```bash
docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]
```

You have an image called `myapp` with tag `latest`, and you want to tag it for Docker Hub under your username (`username/myapp`) as version `v1.0`:

```bash
docker tag myapp:latest username/myapp:v1.0
```

**Docker image pull:**  Downloads an image from a Docker registry (like Docker Hub)

```bash
docker image pull image-name
```

```bash
docker image pull ubuntu:20.04
```

**Docker image push:** Uploads an image to a registry (like Docker Hub).

```bash
docker image push image-name
```

**Docker image inspect:** Shows detailed JSON metadata about an image.outputs data like ID, size, layers, OS, architecture, etc.

```bash
docker image inspect image-name
```

**Docker image save:** Exports a Docker image into a **.tar** file and Sharing an image with others without using Docker Hub

```bash
docker image save -o <file_name>.tar <image_name>:<tag>
```

```bash
docker image save -o myapp_image.tar myapp:latest
```

**Docker image load:** Loads an image from a **.tar** archive into your Docker system.

You receive an image file from someone else.

```bash
docker image load < <file_name>.tar
```

```bash
docker image load -i myapp_image.tar
```

### What is a **Docker Volume**?

A Docker Volume is a persistent storage mechanism used by Docker containers to store data outside the container‚Äôs writable layer. This means:

- Data stored in volumes persists even if the container is deleted or recreated.
- Volumes are managed by Docker, making them easier and safer to use than directly mapping host directories.
- Docker volume is not created inside a container. Instead, a docker volume is created separately form the container and can be mounted to one or more containers.

---

### Why use Docker Volumes?

- Containers are temporary: when you delete a container, any changes or files you added inside it are lost.
- Volumes help save your data even if the container stops or is deleted.
- Useful for databases, logs, or any app data you want to persist.

---

### How Docker Volumes work

- Docker creates a volume stored on the host (location managed by Docker).
- You **mount** this volume inside one or more containers at a specified path.
- Containers can **read and write** to this volume as if it were local storage.

```bash
docker run --name python-c1 -itd -v C:\users\yash\Desktop\myside:/myapp python
```

- Run a Python container named `python-c1` in the background and **mount a bind mount** from your Windows host.
- `v C:\users\yash\Desktop\myside:/myapp`: Mounts your **local folder** into the container at `/myapp`.
- `itd`: Interactive (`i`), TTY (`t`), Detached (`d`). After this, any changes in `C:\users\yash\Desktop\myside` are visible inside the container at `/myapp`, and vice versa.

---

```bash
docker exec -it python-c1 bash
```

- Open an interactive **Bash shell inside the `python-c1` container**.
- `it`: Interactive terminal.
- `bash`: Starts a shell.

**Create Docker Volume:**

```bash
docker volume create myvol
```

- Create a **Docker-managed volume** named `myvol` Data in this volume will persist even if the container using it is removed.

List all volumes on the system.

```bash
docker volume ls
```

Show details about the `myvol` volume, including mount path on the host and usage.

```bash
docker volume inspect myvol
```

 Start a new Python container named `c1` and mount the volume `myvol` at `/myapp` inside the container.

Data written to `/myapp` will be stored in the Docker volume and survive container removal.

```bash
docker run --name c1 -itd -v myvol:/myapp python
```

Open a bash shell inside container `c1`, just like before.

```bash
docker exec -it c1 bash
```

**Docker volume delete:** Deletes the volume named `myvol` You must stop and remove all containers using the volume before this will work.

```bash
docker rm -f c1
docker volume rm myvol
```

## What is **Docker Compose**?

Docker Compose is a tool that allows you to define and manage multi-container Docker applications using a single YAML configuration file (`docker-compose.yml`).

Instead of running multiple `docker run` commands manually, Docker Compose lets you define:

- What services (containers) to run
- What images, volumes, and networks they use
- How they interact with each other

üßæ Example `docker-compose.yml`

```yaml
version: "3"
services:
  web:
    image: nginx
    ports:
      - "80:80"
  redis:
    image: redis
```

This starts two services:

- A web server (Nginx) on port 80 and A Redis server

Create Docker compose

```bash
docker-compose up
```

Add `-d` for detached mode (runs in background):

```bash
docker-compose up -d
```

Stop the app

```bash
docker-compose down
```

List running containers

```bash
docker-compose ps
```

Build images defined in the file

```bash
docker-compose build
```

View logs from services

```bash
docker-compose logs
```

Stops and removes containers, networks, and also deletes volumes associated with the services.

Normally, volumes persist even if you bring the containers down. Adding `--volumes` cleans up volumes, so all data is removed.

```bash
docker-compose down --volumes
```

**Example: Web App + Database**

```yaml
version: "3"
services:
  app:
    build: .
    ports:
      - "5000:5000"
    depends_on:
      - db

  db:
    image: postgres
    environment:
      POSTGRES_PASSWORD: example
```

- `app` is built from a Dockerfile in the current directory
- `db` is a PostgreSQL container
- The app depends on the database

### **How to use a `.env` file with Docker Compos**

- Docker Compose automatically looks for a `.env` file in the same directory as the `docker-compose.yml`.
- This file is used to set environment variables referenced in your Compose file.

**Example `.env` file:**

```bash
MYSQL_ROOT_PASSWORD=mysecretpassword
REDIS_PORT=6379
```

Example `docker-compose.yml` referencing these variables:

```bash
version: "3"
services:
  db:
    image: mysql
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
  redis:
    image: redis
    ports:
      - "${REDIS_PORT}:6379"
```